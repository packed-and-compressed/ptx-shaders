#include "../../../common/util.sh"
#ifdef SPLINE_STROKE_COMPOSITE	

//this mode just uses a mask texture generated by paint strokes
USE_TEXTURE2D(tStrokeMask);

bool mapCompositeArea(inout LayerState state)
{
	float mask = texture2D(tStrokeMask, state.bufferCoord).r;		//TODO:  sparse sampling
	state.layerMask *= mask;
	return (mask > 0.0);
}

#else
#include "discretespline.frag"


#ifdef LAYER_SH
#ifdef SPLINE_FILL_SDF

void splitFlags(inout float val, inout int flags)
{
	int i = (int)(val * 65535.0);
	flags = i & 15;
	val = ((float)(i&65520)) / 65535.0;
}

bool mapCompositeArea(inout LayerState state)
{	
	vec3 pos = vec3(state.bufferCoord, 0.0);
	state.splineUV = state.texCoord;
	
	vec2 uv = vec2(0.0, 0.0);
	
#ifdef EFFECT_POSITIONAL
	pos = state.position.xyz;
	#ifndef MATERIAL_PASS_PAINT
		pos = mulPoint(uModelViewInv, pos).xyz;	//fix multiplication of projector matrix
	#endif
	pos = mulPoint(uMeshTransform, pos).xyz;
#endif
	
	//derivatives for AA
	vec3 dpdx = dFdx(pos);
	vec3 dpdy = dFdy(pos);
	float dP = length(dpdx+dpdy);
	uint2 lookupSize; uint lookupMips;
	imageSize2D( tFillMask, lookupSize.x, lookupSize.y, lookupMips );
	uint2 coord = uint2(state.bufferCoord.x * lookupSize.x, (1.0 - state.bufferCoord.y) * lookupSize.y);	
	vec4 fillMask = imageLoad( tFillMask, coord);
	float sdf = fillMask.r;
	int flags;
	splitFlags(sdf, flags);
	int AAi = (flags&15) + 1;	//1-16
	float mask = ceil(sdf);
	float dV = abs(dFdx(sdf)) + abs(dFdy(sdf));
	float edgeDistPixels = sdf / max(dP/uRadius, 0.0000001);
	if(uQuantizedAA == 0.0)
	{
		mask = saturate(edgeDistPixels / max(uEdgeAA, 0.00001));
		
		//force inside pixels to 1.0 or the abrupt change in derivative can cause artifacts
		mask = mix(mask, 1.0, step(1.0, sdf+dV));
	}
	else
	{ mask *= ((float)AAi) / 16.0;  }
	state.layerMask *= mask;
	state.splineUV = vec2(clamp(sdf * 0.5, 0.0, 0.5), 0.5);
#ifdef SPLINE_CONTOUR
	vec4 contourData = texture2D(tContourData, state.splineUV);
	state.splineContourHeight = contourData.x;
	state.splineCorrectedU = contourData.y;
	state.splineContourAO = contourData.z;
	state.splineUV = vec2(0.5, 0.5);
	state.distortedSplineUV = adjustSplineCoord(state.splineUV, state.splineCorrectedU);
#endif	

	
	return (mask > 0.f); 
}

#else 	// SPLINE_FILL undefined
bool mapCompositeArea(inout LayerState state)
{	
	vec3 pos = vec3(state.bufferCoord, 0.0);
	state.splineUV = state.texCoord;
	
	vec2 uv = vec2(0.0, 0.0);
	
#ifdef EFFECT_POSITIONAL
	pos = state.position.xyz;
	#ifndef MATERIAL_PASS_PAINT
		pos = mulPoint(uModelViewInv, pos).xyz;	//fix multiplication of projector matrix
	#endif
	pos = mulPoint(uMeshTransform, pos).xyz;
#endif
	
	//derivatives for AA
	vec3 dpdx = dFdx(pos);
	vec3 dpdy = dFdy(pos);
	float dP = length(dpdx + dpdy);
	//early out if we're not in the bounding box of the curve
	vec3 inBounds = step(uBoundsMin, pos + uRadius * 3.5f) * step(pos - uRadius * 1.5, uBoundsMax);
	if(dot(inBounds, inBounds) < 2.9)
	{ return false; }
	
	//determine which segment we are nearest
	int bestSeg = -1;
	Segment seg;
	uint2 lookupSize; uint lookupMips;
	imageSize2D( tSegmentLookup, lookupSize.x, lookupSize.y, lookupMips );	
	float lookup = imageLoad( tSegmentLookup, uint2( state.bufferCoord.x * lookupSize.x, (1.0 - state.bufferCoord.y) * lookupSize.y	)).x;

	if(lookup == 1.0)
	{ 
		state.splineUV = vec2(0.5, 0.5);
		//fully internal
#ifdef SPLINE_CONTOUR
		vec4 contourData = texture2DLod(tContourData, vec2(0.5, 0.5), 0.0);
		state.splineContourHeight = contourData.x;
		state.splineCorrectedU = contourData.y;
		state.splineContourAO = 0.0;
		state.distortedSplineUV = adjustSplineCoord(state.splineUV, state.splineCorrectedU);
#endif	
		return true; 
	}
	
	bestSeg = (int)(lookup * mix(65535.0, 255.0, (float)uR8Lookup)) - 1; 
	if(bestSeg == -1)
	{ return false; }

	//get segment data and our distorted UV coords
	float radiusMult = 1.25;
	float bestPerpDistSquared = uRadius * uRadius * radiusMult * radiusMult;
	float alpha = 0.0;

	LocalData ld = checkSegment(bestSeg, pos, bestPerpDistSquared, alpha, seg, radiusMult, dP, dpdx, dpdy);
	if(!ld.inSegment)
	{ return false; }
	vec2 segmentUV = ld.segmentUV;
	state.splineUV = ld.splineUV;
	alpha = ld.maskAlpha;
	float ss = (float)bestSeg/255.0;


#ifdef SPLINE_FILL
	//for fills, splineUV goes from 0-0.5
	state.splineUV.x = mix(state.splineUV.x, 1.0-state.splineUV.x, (float)seg.rightHanded) - 0.5;
	
	//update the values used for AA
	segmentUV.x = state.splineUV.x;
	pos = mix(seg.pos1, seg.pos2, segmentUV.y) + mix(seg.perp1, seg.perp2, segmentUV.y) * uRadius * (segmentUV.x - 0.5) * 2.0;
#endif

	//do some antialiasing on the edges
	//re-distort so we have the proper modified position for the AA pass
	vec3 pos2 = pos;
	float radiusMult2 = 1.0;
	distortSpline(pos2, radiusMult2, vec2((ld.segmentUV.x - 0.5) * radiusMult + 0.5, ld.segmentUV.y), ld.splineUV.y * 2.0, seg, ld.testData);
	
	//and apply any position shift/defascetization
	pos2 += ld.positionShift;
	ld.AA *= antialiasSegment2(seg, pos2, segmentUV, dpdx, dpdy, ld.splineUV.y, radiusMult2 * uRadius);
	
	//quantize AA?
	float aaSteps = 8.0;
	ld.AA = mix(ld.AA, floor(ld.AA * aaSteps + 0.5) / aaSteps, uQuantizedAA);
	alpha *= ld.AA;
#ifdef SPLINE_FILL
	if(state.splineUV.x < 0.0)
	{ return false; }
#endif

	state.splineUV.y *= getVMultiplier(seg.pathLength, seg.shapeLooped);
			
//	state.splineDebugData = vec4(segmentUV, 0.0, 1.0);
	//contour data
	state.splineContourHeight = 0.0;
	state.splineCorrectedU = state.splineUV.x;
	state.splineContourAO = 1.0;
	state.distortedSplineUV = state.splineUV;
	float contourGradientCorrection = 1.0;
#ifdef SPLINE_CONTOUR
	float contourLOD = 0.0;
	{
		uint2 size; uint mipCount;
		imageSize2D( tContourData, size.x, size.y, mipCount );
		float avgSize = sqrt((float)(size.x * size.y));
		float dPX = avgSize*dP / uRadius / 2.0;	//delta texels per pixel
		contourLOD = max(log(dPX)/log(2.0), 0.0);
	}

	vec4 contourData = texture2DLod(tContourData, state.splineUV, contourLOD);
	state.splineContourHeight = contourData.x;
	state.splineCorrectedU = contourData.y;
	state.splineContourAO = contourData.z;
	state.distortedSplineUV = adjustSplineCoord(state.splineUV, state.splineCorrectedU);
//	contourGradientCorrection = mix(1.0, contourData.a * 10.0, saturate(abs(uContourAmplitude)));
#endif	

	state.layerMask *= alpha;
//use spline projection unless we're using it as a positional trigger for plain ol UV projection
#if defined(EFFECT_SPLINE_PROJECTION) && !defined(SPLINE_MATERIAL_UV_PROJECTION)
	state.texCoord = mulPoint2(uMaskTransform, state.distortedSplineUV);
	fixSplineSpaceTextureSampling(vec2(state.distortedSplineUV.x, ld.segmentUV.y), 
		state.distortedSplineUV, seg, dpdx, dpdy, ld.dUVdxLocal * contourGradientCorrection, ld.dUVdyLocal, state.dUVdx, state.dUVdy);
	
	state.dUVdx = mulVec2(uMaskTransform, state.dUVdx);
	state.dUVdy = mulVec2(uMaskTransform, state.dUVdy);
	
	//for spline projection, we need to make new tangent and bitangents
	#ifdef MATERIAL_PASS_PAINT
		state.tangent = vec3(1.0, 0.0, 0.0);
		state.bitangent = vec3(0.0, 1.0, 0.0);
		state.normal = vec3(0.0, 0.0, 1.0);
	#endif
#endif
	
	return true;	
}

#endif //SPLINE_FILL undefined
#endif //LAYER_SH defined
#endif //SPLINE_STROKE_COMPOSITE undefined
