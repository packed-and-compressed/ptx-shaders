#ifndef MSET_LIGHTS_POINTLIGHT_COMP
#define MSET_LIGHTS_POINTLIGHT_COMP

#include "data/shader/mat/light.comp"
#include "data/shader/mat/state.comp"
#include "sphericalrect.comp"

//#define RT_SPHERICAL_RECTANGLES

#define RT_SMALL_SPHERE_SOLIDANGLE	1e-4
#define RT_SMALL_RECT_SOLIDANGLE	1e-4

void evaluateLight_Point( LightParamsRT lp, vec3 origin, float maxt, inout LightSampleState s )
{
	float t = INFINITY;
	float radius = lp.size.z;
	if( radius > 0.0 )
	{
	#ifdef SceneHasPointLights_Spherical
		//spherical area light
		float r2 = radius * radius;
		float a  = dot( s.L, s.L );
		float b  = 2.0 * dot( s.L, -lp.toSource );
		float c  = dot( lp.toSource, lp.toSource ) - r2;
		float disc = b*b - 4.0*a*c;
		if( disc >= 0.0 )
		{
			vec2 bothT = vec2( -b - sqrt(disc), -b + sqrt(disc) ) / (2.0 * a);
			t = ( bothT.x * bothT.y ) < 0.0 ? max( bothT.x, bothT.y ) : min( bothT.x, bothT.y );
		}
	#endif
	}
	else
	{
	#ifdef SceneHasPointLights_Rectangular
		//rectangular area light
		float LdotZ = dot( s.L, lp.axisZ );
		if( LdotZ != 0.0 )
		{
			t = dot( lp.toSource, lp.axisZ ) * rcp( LdotZ );
			vec3 p0 = t * s.L;
			vec3 r  = p0 - lp.toSource;
			vec2 uv = vec2( dot( r, lp.axisX ), dot( r, lp.axisY ) );
			HINT_FLATTEN if( abs(uv.x) > 0.5*lp.size.x || abs(uv.y) > 0.5*lp.size.y )
			{ t = INFINITY; }
		}
	#endif
	}

	if( t >= 0.0 && t < maxt )
	{
		s.radiance = lp.color;
		s.distance = lp.castShadows ? t : -t; //encode cast shadows flag in distance sign bit

		float area = lp.size.x * lp.size.y;
		if( radius > 0.0 )
		{
		#ifdef SceneHasPointLights_Spherical
			//spherical area light
			float r2 = radius * radius;
			//solid angle subtended by light sphere
			float sinThetaL2 = r2 * lp.invDistance2;
			if( lp.distance <= radius )
			{
				//shading point lies inside of light sphere
				//intersection point on light surface
				vec3 Lp = origin + s.L * t;
				//direction vector from light center to sampled point (normal vector at Lp)
				vec3 Ln = normalize( Lp - lp.position );
				//pdf with respect to area converted to solid angle measure
				float NdotL = abs( dot( Ln, s.L ) );
				float d2 = t * t;
				s.pdf = d2 * INVFOURPI * ( NdotL != 0.0 ? rcp( r2 * NdotL ) : 0.0 );
			}
			else if( sinThetaL2 <= RT_SMALL_SPHERE_SOLIDANGLE )
			{
				//spherical light subtends small solid angle; fall back to uniform disk sampling
				//pdf with respect to area converted to solid angle measure
				float d2 = t * t;
				area  = PI * radius * radius;
				s.pdf = d2 * rcp( area );
			}
			else
			{
				//solid angle sampling
				float cosThetaL = sqrt( 1.0 - sinThetaL2 );
				//pdf with respect to solid angle
				s.pdf = INVTWOPI * rcp( 1.0 - cosThetaL );
			}
		#endif
		}
		else
		{
		#ifdef SceneHasPointLights_Rectangular
			//rectangular area light
		#ifdef RT_SPHERICAL_RECTANGLES
			//conservative estimate of solid angle subtended by light rect
			float r = min( lp.size.x, lp.size.y );
			float sinThetaL2 = r*r * lp.invDistance2;
			if( sinThetaL2 <= RT_SMALL_RECT_SOLIDANGLE )
		#endif
			{
				//uniform rect sampling
				float LdotZ = dot( s.L, lp.axisZ );
				float d2 = t * t;
				s.pdf = d2 * rcp( abs(LdotZ) * area );
			}
		#ifdef RT_SPHERICAL_RECTANGLES
			else
			{
				//spherical rect solid angle sampling
				SphericalRect rect = createSphericalRect( l, origin );
				s.pdf = pdfSphericalRect( rect );
			}
		#endif
		#endif
		}
	}
}

template<bool resampledDirect>
void evaluateDirectLight_Point( LightParamsRT lp, vec3 origin, float maxt, inout LightSampleState s )
{
	float t = INFINITY;
	float radius = lp.size.z;
	float area = lp.size.x * lp.size.y;
	if( radius > 0.0 )
	{
	#ifdef SceneHasPointLights_Spherical
		if( resampledDirect )
		{
			t = lp.distance;
		}
		else
		{

			// spherical area light
			float r2 = radius * radius;
			float a = dot( s.L, s.L );
			float b = 2.0 * dot( s.L, -lp.toSource );
			float c = dot( lp.toSource, lp.toSource ) - r2;
			float disc = b * b - 4.0 * a * c;
			if( disc >= 0.0 )
			{
				vec2 bothT = vec2( -b - sqrt( disc ), -b + sqrt( disc ) ) / ( 2.0 * a );
				t = ( bothT.x * bothT.y ) < 0.0 ? max( bothT.x, bothT.y ) : min( bothT.x, bothT.y );
			}
		}
	#endif
	}
	else if( area > 0.0f )
	{
	#ifdef SceneHasPointLights_Rectangular
		if( resampledDirect )
		{
			t = lp.distance;
		}
		else
		{
			// rectangular area light
			float LdotZ = dot( s.L, lp.axisZ );
			if( LdotZ != 0.0 )
			{
				t = dot( lp.toSource, lp.axisZ ) * rcp( LdotZ );
				vec3 p0 = t * s.L;
				vec3 r = p0 - lp.toSource;
				vec2 uv = vec2( dot( r, lp.axisX ), dot( r, lp.axisY ) );
				HINT_FLATTEN if( abs( uv.x ) > 0.5 * lp.size.x || abs( uv.y ) > 0.5 * lp.size.y )
				{
					t = INFINITY;
				}
			}
		}
	#endif
	}
	else
	{
		// point light
		s.L = lp.direction;
		s.distance = lp.distance;
		s.radiance = lp.color * lp.invDistance2;// convert intensity to radiance
		s.pdf = -1.0;				  // delta distribution light

		HINT_FLATTEN if( !lp.castShadows )
		{
			s.distance = 0.0;
		}
	}

	if( t >= 0.0 && t < maxt )
	{
		s.radiance = lp.color;
		s.distance = lp.castShadows ? t : -t; //encode cast shadows flag in distance sign bit

		if( radius > 0.0 )
		{
		#ifdef SceneHasPointLights_Spherical
			//spherical area light
			float r2 = radius * radius;
			//solid angle subtended by light sphere
			float sinThetaL2 = r2 * lp.invDistance2;
			if( lp.distance <= radius )
			{
				//shading point lies inside of light sphere
				//intersection point on light surface
				vec3 Lp = origin + s.L * t;
				//direction vector from light center to sampled point (normal vector at Lp)
				vec3 Ln = normalize( Lp - lp.position );
				//pdf with respect to area converted to solid angle measure
				float NdotL = abs( dot( Ln, s.L ) );
				float d2 = t * t;
				s.pdf = d2 * INVFOURPI * ( NdotL != 0.0 ? rcp( r2 * NdotL ) : 0.0 );
			}
			else if( sinThetaL2 <= RT_SMALL_SPHERE_SOLIDANGLE )
			{
				//spherical light subtends small solid angle; fall back to uniform disk sampling
				//pdf with respect to area converted to solid angle measure
				float d2 = t * t;
				area  = PI * radius * radius;
				s.pdf = d2 * rcp( area );
			}
			else
			{
				//solid angle sampling
				float cosThetaL = sqrt( 1.0 - sinThetaL2 );
				//pdf with respect to solid angle
				s.pdf = INVTWOPI * rcp( 1.0 - cosThetaL );
			}
		#endif
		}
		else
		{
		#ifdef SceneHasPointLights_Rectangular
			//rectangular area light
		#ifdef RT_SPHERICAL_RECTANGLES
			//conservative estimate of solid angle subtended by light rect
			float r = min( lp.size.x, lp.size.y );
			float sinThetaL2 = r*r * lp.invDistance2;
			if( sinThetaL2 <= RT_SMALL_RECT_SOLIDANGLE )
		#endif
			{
				//uniform rect sampling
				float LdotZ = dot( s.L, lp.axisZ );
				float d2 = t * t;
				s.pdf = d2 * rcp( abs(LdotZ) * area );
			}
		#ifdef RT_SPHERICAL_RECTANGLES
			else
			{
				//spherical rect solid angle sampling
				SphericalRect rect = createSphericalRect( l, origin );
				s.pdf = pdfSphericalRect( rect );
			}
		#endif
		#endif
		}
	}
}

void sampleLight_Point( LightParamsRT lp, vec2 r, vec3 origin, inout LightSampleState s )
{
	s.radiance   = lp.color;
	float area   = lp.size.x * lp.size.y;
	float radius = lp.size.z;
	if( radius > 0.0 )
	{
	#ifdef SceneHasPointLights_Spherical
		//spherical area light
		float r2 = radius * radius;
		//solid angle subtended by light sphere
		float sinThetaL2 = r2 * lp.invDistance2;
		if( lp.distance <= radius )
		{
			//shading point lies inside of light sphere
			//uniformly sample direction vector
			float cosTheta = 1.0 - 2.0*r.x;
			float sinTheta = sqrt( 1.0 - cosTheta*cosTheta );
			float phi      = r.y * TWOPI;

			//pick a point on light surface in the sampled direction
			vec3 Ln = vec3( cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta );
			vec3 Lp = lp.position + Ln * radius;

			//direction and distance to sampled point
			s.L = Lp - origin;
			float d2 = dot( s.L, s.L );
			s.distance = sqrt( d2 );
			s.L *= rcp( s.distance );

			//pdf with respect to area converted to solid angle measure
			float NdotL = abs( dot( Ln, s.L ) );
			s.pdf = d2 * INVFOURPI * ( NdotL != 0.0 ? rcp( r2 * NdotL ) : 0.0 );
		}
		else if( sinThetaL2 <= RT_SMALL_SPHERE_SOLIDANGLE )
		{
			//spherical light subtends small solid angle; fall back to uniform disk sampling
			//local basis around direction towards light center
			TangentBasis basis = createTangentBasis( lp.direction );

			//uniformly sample point on a disk oriented towards shading point
			float sqrtR = radius * sqrt( r.x );
			float theta = r.y * TWOPI;
			vec2  uv 	= vec2( sqrtR * cos(theta), sqrtR * sin(theta) );
			vec3  Lp 	= lp.position + uv.x * basis.T + uv.y * basis.B;

			//direction and distance to sampled point
			s.L = Lp - origin;
			float d2 = dot( s.L, s.L );
			s.distance = sqrt( d2 );
			s.L *= rcp( s.distance );

			//pdf with respect to area converted to solid angle measure
			area  = PI * radius * radius;
			s.pdf = d2 * rcp( area );
		}
		else
		{
			//spherical rect solid angle sampling
			//solid angle subtended by light sphere
			float cosThetaL = sqrt( max( 1.0 - sinThetaL2, 0.0 ) );

			//uniformly sample a direction vector within thetaL cone
			float cosTheta = (1.0 - r.x) + r.x * cosThetaL;
			float sinTheta = sqrt( 1.0 - cosTheta*cosTheta );
			float phi      = r.y * TWOPI;

			//distance to sampled point on light surface
			s.distance = lp.distance * cosTheta - sqrt( max( r2 - lp.distance*lp.distance * sinTheta*sinTheta, 0.0 ) );

			//local basis around direction towards light center
			TangentBasis basis = createTangentBasis( lp.direction );

			//sampled direction vector
			vec3 L_t = vec3( cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta );
			s.L = transformVecFrom( basis, L_t );

			//pdf with respect to solid angle
			s.pdf = INVTWOPI * rcp( 1.0 - cosThetaL );
		}
	#endif
	}
	else if( area > 0.0 )
	{
	#ifdef SceneHasPointLights_Rectangular
		//rectangular area light
	#ifdef RT_SPHERICAL_RECTANGLES
		//conservative estimate of solid angle subtended by light rect
		float sr = min( lp.size.x, lp.size.y );
		float sinThetaL2 = sr*sr * lp.invDistance2;
		if( sinThetaL2 <= RT_SMALL_RECT_SOLIDANGLE )
	#endif
		{
			//fall back to uniformly sampling light rectangle
			vec2  uv = vec2( r.x - 0.5, r.y - 0.5 ) * lp.size.xy;
			vec3  Lp = lp.position + uv.x * lp.axisX + uv.y * lp.axisY;

			//direction and distance to sampled point
			s.L = Lp - origin;
			float d2 = dot( s.L, s.L );
			s.distance = sqrt( d2 );
			s.L *= rcp( s.distance );

			//pdf with respect to area converted to solid angle measure
			float LdotZ = abs( dot( s.L, lp.axisZ ) );
			s.pdf = LdotZ != 0.0 ? d2 * rcp( LdotZ * area ) : 0.0;
		}
	#ifdef RT_SPHERICAL_RECTANGLES
		else
		{
			//create spherical rectangle mapping w.r.t. shading point
			SphericalRect rect = createSphericalRect( l, origin );

			//sample point on light surface
			vec3 Lp = sampleSphericalRect( rect, origin, r.xy );
			s.L = Lp - origin;
			s.distance = length( s.L );
			s.L *= rcp( distance );

			//pdf with respect to solid angle
			float LdotZ = dot( s.L, lp.axisZ );
			s.pdf = LdotZ != 0.0 ? pdfSphericalRect( rect ) : 0.0;
		}
	#endif
	#endif
	}
	else
	{
		//point light
		s.L = lp.direction;
		s.distance = lp.distance;
		s.radiance *= lp.invDistance2; //convert intensity to radiance
		s.pdf = -1.0; //delta distribution light
	}

	HINT_FLATTEN if( !lp.castShadows )
	{ s.distance = 0.0; }
}

#endif