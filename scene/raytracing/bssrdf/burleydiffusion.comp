#ifndef MSET_BSSRDF_BURLEYDIFFUSION_H
#define MSET_BSSRDF_BURLEYDIFFUSION_H

#include "data/shader/mat/fresnel.frag"

//BSSRDF using Burley normalized diffusion profile
//see "Approximate Reflectance Profiles for Efficient Subsurface Scattering", P. Christensen, B. Burley
//importance sampling scheme based on https://www.arnoldrenderer.com/research/s2013_bssrdf_slides.pdf

//normalized diffusion profile value at rmax (u=0.999)
#define BURLEY_DIFFUSION_RMAX	19.860222

//sample normalized diffusion profile for given scatter depth (single channel)
//based on CDF^(-1) derivation by Evgenii Golubev, https://zero-radiance.github.io/post/sampling-diffusion/
float sampleBurleyDiffusion( float u, float scatterDepth )
{
	u = 1.0 - u; //sample from CCDF
	float u4 = 4.0 * u;
	float g  = 1.0 + u4 * ( 2.0*u + sqrt(1.0 + u * u4) );
	float g1 = pow( g, -1.0/3.0 );
	float g2 = g * (g1 * g1); //g^(1/3)
	float x  = 3.0 * log( (1.0 + g1 + g2) * rcp(u4) );
	return x * scatterDepth;
}

vec3 pdfBurleyDiffusion( float r, vec3 scatterDepth )
{
	//NOTE: PDF is multiplied by 2*PI*r to match sampling CDF (as per section 6)
	vec3 exp_r3d = exp( -r/(3.0*scatterDepth) );
	vec3 exp_rd  = exp_r3d * exp_r3d * exp_r3d;
	return ( exp_rd + exp_r3d ) * rcp( scatterDepth ) * 0.25;
}

float sampleBSSRDF_BurleyDiffusionPosition( inout SampleState s, vec3 scatterDepth, out uint rayAxis, out float rayMaxT )
{
	//sample scatter depth channel
	float scatterDepthCh = s.r.z < (2.0/3.0) ? ( s.r.z < (1.0/3.0) ? scatterDepth.r : scatterDepth.g ) : scatterDepth.b;

	//sample diffusion profile in polar coordinates
	float r	   = sampleBurleyDiffusion( s.r.x, scatterDepthCh );
	float phi  = TWOPI * s.r.y;
	//diffusion radius upper bound (contains 99.9% of scattered energy)
	float rmax = BURLEY_DIFFUSION_RMAX * scatterDepthCh;

	//fail if sampled beyond the upper bound (clamping would introduce bias)
	if( r >= rmax )
	{
		rayAxis = 0;
		rayMaxT = 0.0; 
		return 0.0; 
	}
    
	//use tangent basis around geometric normal for probe rays sampling axis
	TangentBasis basis = createTangentBasis( s.Ng );

	//choose sampling axis
	vec3 X, Y, Z;
	HINT_FLATTEN
	if( s.r.w < 0.5 ) //sample along normal vector (50% chance)
	{ 
		X = basis.T; Y = basis.B; Z = basis.N;
		rayAxis = 0; //Z=N
	}
	else if( s.r.w < 0.75 ) //sample along tangent vector (25% chance)
	{
		X = basis.N; Y = basis.B; Z = basis.T;
		rayAxis = 1; //Z=T
	}
	else //sample along bitangent vector (25% chance)
	{
		X = basis.T; Y = basis.N; Z = basis.B;
		rayAxis = 2; //Z=B
	}

	//calculate probe ray origin and direction
	float l		= sqrt( rmax*rmax - r*r );
	s.origin   += r * ( X * cos(phi) + Y * sin(phi) ) + Z * l;
	s.L			= -Z;
	//max probe ray length
	rayMaxT		= 2.0 * l;

	return r;
}

vec3 evaluateBSSRDF_BurleyDiffusionPosition( SampleState s, vec3 albedo, vec3 scatterDepth,
											 vec3 subsurfaceOrigin, vec3 subsurfaceNormal, float subsurfaceRadius, uint subsurfaceAxis, uint hitCount )
{
	//recreate tangent basis at ray entry point (BSSRDF exit point)
	TangentBasis subsurfaceBasis = createTangentBasis( subsurfaceNormal );

	//select X, Y, Z to match probe ray axis
	vec3 X, Y, Z;
	HINT_FLATTEN
	if( subsurfaceAxis == 0 )
	{
		X = subsurfaceBasis.T;
		Y = subsurfaceBasis.B;
		Z = subsurfaceBasis.N;
	}
	else if( subsurfaceAxis == 1 )
	{
		X = subsurfaceBasis.N;
		Y = subsurfaceBasis.B;
		Z = subsurfaceBasis.T;
	}
	else
	{
		X = subsurfaceBasis.T;
		Y = subsurfaceBasis.N;
		Z = subsurfaceBasis.B;
	}

	//each axis sampling PDF
	float pdfZ = abs( dot( s.Ng, Z ) ) * ( subsurfaceAxis == 0 ? 0.5 : 0.25 );
	float pdfX = abs( dot( s.Ng, X ) ) * ( subsurfaceAxis == 1 ? 0.5 : 0.25 );
	float pdfY = abs( dot( s.Ng, Y ) ) * ( subsurfaceAxis == 2 ? 0.5 : 0.25 );

	//combined axis sampling weight (MIS with power heuristic)
	//NOTE: pdfZ in MIS weight and denominator cancelled out ~ms
	float weight = pdfZ * rcp( pdfX*pdfX + pdfY*pdfY + pdfZ*pdfZ ) * hitCount;

	//effective diffusion radius
	float r = length( subsurfaceOrigin - s.origin );

	//diffusion profile sampling PDF (w.r.t. original sampled radius)
	vec3 bssrdf_pdf = pdfBurleyDiffusion( subsurfaceRadius, scatterDepth );
	float pdf = (1.0/3.0) * ( bssrdf_pdf.x+bssrdf_pdf.y+bssrdf_pdf.z );

	//final BSSRDF weight (w.r.t. effective radius)
	vec3 bssrdf = albedo * pdfBurleyDiffusion( r, scatterDepth ) * weight;
	return pdf > 0.0 ? bssrdf * rcp( pdf ) : vec3( 0.0, 0.0, 0.0 );
}

void sampleBSSRDF_BurleyDiffusionDirection( inout SampleState s )
{
	vec3 L_t = sampleHemisphereCosine_t( s.r.xy );

	s.NdotL	= L_t.z; //shading space cos theta
	s.L		= normalize( transformVecFrom( s.basis, L_t ) );
	s.H		= s.L;
}

void evaluateBSSRDF_BurleyDiffusionDirection( inout SampleState s, vec3 transmissivity )
{
	//even though this is technically a transmission event make sure to evaluate
	//BSSRDF direction component only towards the "outside" hemisphere ~ms
	if( isReflection(s) )
	{
		float Fin = fresnelSchlick( s.NdotL );
		float T   = 1.0 - 0.5 * Fin;

		float pdf = s.NdotL * INVPI;
		s.bsdf += T * transmissivity * pdf;
		s.pdf  += pdf * s.transmissionWeight;
	}
}

#endif