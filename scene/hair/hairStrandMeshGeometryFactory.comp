#include "data/shader/common/meshBuffer.comp"
#include "data/shader/common/tangentbasis.sh"
#include "hairStrandCommon.comp"
#include "hairMesh.comp"
#include "data/shader/common/rng.comp"

#define STRAND_ORIENTATION_MODE_CAMERA_ALIGNED (0)
#define STRAND_ORIENTATION_MODE_FIXED (1)

uniform float 	uRandomOrientation;

uniform float   uStrandWidth;
uniform float   uHairRootScale;
uniform float   uHairTipScale;
uniform uint    uNumStrands;

// This contains points that has been evaluted on the CPU side during import given the curve type
// they are essentially discretized line segments we can make quads from
USE_STRUCTUREDBUFFER(HairStrand, bStrandsBuffer);
USE_STRUCTUREDBUFFER(HairVertex, bPositionsBuffer);
USE_BUFFER(vec2, bRootUVsBuffer);

// Output
USE_INTERLOCKED_BUFFER(bMeshVertices, 0);
USE_INTERLOCKED_BUFFER(bMeshTexCoords1, 1);
USE_INTERLOCKED_BUFFER(bMeshIndices, 2);
USE_INTERLOCKED_BUFFER(bMeshWireframeIndices, 3);
USE_INTERLOCKED_BUFFER(bMeshVertexColors, 4);

void storeVertexStandard( uint vertexOffset, VertexStandard v )
{
    const uint meshBufferOffset = vertexIndexToMeshBufferOffset( vertexOffset, false );
    const uint meshTangentBufferOffset = applyTangentOffsetToMeshBufferOffset( meshBufferOffset );
    const uint meshUVBufferOffset = applyUVOffsetToMeshBufferOffset( meshBufferOffset );

	const uint2 tn = uint2( v.tangent, v.normal );
	interlockedStore3( bMeshVertices, meshBufferOffset, asuint_packed_vec3( v.position ) );
    interlockedStore2( bMeshVertices, meshTangentBufferOffset, tn );
    interlockedStore2( bMeshVertices, meshUVBufferOffset, asuint_packed_vec2( v.texcoord ) );
}

void storeMeshTexCoord1( uint vertexOffset, vec2 texcoord )
{
	interlockedStore2( bMeshTexCoords1, vertexOffset * 2, asuint( texcoord ) );
}

void storeMeshVertexColor( uint vertexOffset, vec3 color )
{
	uint c = uint(color.x * 255.0) |
			(uint(color.y * 255.0) << 8) |
			(uint(color.z * 255.0) << 16) |
			0xFF000000;
	interlockedStore( bMeshVertexColors, vertexOffset, c );
}

COMPUTE(64, 1, 1)
{
    if( DISPATCH_THREAD_ID.x >= uNumStrands )
    {
    	return;
    }
    
	RNG rng = rngInit( DISPATCH_THREAD_ID.x, 0 );

    // Each thread processes one strand, then builds a quad for each segment
    // the vertices are stored in bMeshVertices
    const HairStrand strand = bStrandsBuffer[DISPATCH_THREAD_ID.x];
    const vec2		 rootUV = bRootUVsBuffer[DISPATCH_THREAD_ID.x];
    vec3		 	 viewDir = vec3( 0.0, 1.0, 0.0 ); //orient with up vector by default

	if ( rngNextFloat( rng ) < uRandomOrientation )
	{ viewDir = normalize( rngNextVec3( rng ) ); }

    uint			 vertexOffset = strand.vertexOffset;
    uint			 indexOffset = strand.indexOffset;
    uint			 wireframeIndexOffset = strand.wireframeIndexOffset;
    vec3			 previousLeft = vec3( 0.0, 0.0, 0.0 );
    vec3			 previousRight = vec3( 0.0, 0.0, 0.0 );
    
    // Only iterate from 0 to size-1, We don't process the last vertex
    for( uint i = 0; i < strand.size - 1; ++i )
    {
    	const float		 t = float( i ) / float( strand.size - 1 );
    	const float		 scale = lerp( uHairRootScale, uHairTipScale, t );
    
    	const uint		 index = strand.offset + i;
    
    	const HairVertex currentVertex = bPositionsBuffer[index];
    	const HairVertex nextVertex = bPositionsBuffer[index + 1];
    	const vec3		 currentPosition = currentVertex.position;
    	const vec3		 nextPosition = nextVertex.position;
		const vec3 		 currentColor = currentVertex.color;
		const vec3 		 nextColor = nextVertex.color;
    
    	const float		 radius = lerp( currentVertex.radius, nextVertex.radius, t ) * uStrandWidth;
    
    	const vec3 		 tangent = normalize( nextPosition - currentPosition );
    	const vec3 		 bitangent = normalize( cross( tangent, viewDir ) );
    	const vec3		 normal = normalize( cross( tangent, bitangent ) );

    	const vec3		 width = bitangent * radius * scale;
    	const vec3		 cvLeft = i == 0 ? currentPosition - width : previousLeft;
    	const vec3		 cvRight = i == 0 ? currentPosition + width : previousRight;
    	const vec3		 nvLeft = nextPosition - width;
    	const vec3		 nvRight = nextPosition + width;
    
    	previousLeft = nvLeft;
    	previousRight = nvRight;
    
    	uint2 tn;
    	tn.x = packVector( tangent, establishHandedness( tangent, bitangent, normal ) );
    	tn.y = packVector( normal );

		// Quad configuration
		// 0---1
		// | / |
		// 2---3
		storeVertexStandard( vertexOffset + 0, makeVertexStandard( cvLeft, tn[0], tn[1], rootUV ) );
		storeVertexStandard( vertexOffset + 1, makeVertexStandard( cvRight, tn[0], tn[1], rootUV ) );
		storeVertexStandard( vertexOffset + 2, makeVertexStandard( nvLeft, tn[0], tn[1], rootUV ) );
		storeVertexStandard( vertexOffset + 3, makeVertexStandard( nvRight, tn[0], tn[1], rootUV ) );

		storeMeshVertexColor( vertexOffset + 0, currentColor );
		storeMeshVertexColor( vertexOffset + 1, currentColor );
		storeMeshVertexColor( vertexOffset + 2, nextColor );
		storeMeshVertexColor( vertexOffset + 3, nextColor );

        // x component stores the w coordinate along the strand
        // y coordinate packs the uv across the width of the strand ( either 0 or 1 ) along with strand id
        const uint strandId = ( DISPATCH_THREAD_ID.x & 0x7FFFFFFF );
		storeMeshTexCoord1( vertexOffset + 0, vec2( currentVertex.t, asfloat( strandId ) ) );
		storeMeshTexCoord1( vertexOffset + 1, vec2( currentVertex.t, asfloat( (1 << 31) | strandId ) ) );
		storeMeshTexCoord1( vertexOffset + 2, vec2( nextVertex.t, asfloat( strandId ) ) );
		storeMeshTexCoord1( vertexOffset + 3, vec2( nextVertex.t, asfloat( (1 << 31) | strandId ) ) );
		
        interlockedStore( bMeshIndices, indexOffset + 0, vertexOffset + 0 );
        interlockedStore( bMeshIndices, indexOffset + 1, vertexOffset + 2 );
        interlockedStore( bMeshIndices, indexOffset + 2, vertexOffset + 1 );
        interlockedStore( bMeshIndices, indexOffset + 3, vertexOffset + 3 );
        interlockedStore( bMeshIndices, indexOffset + 4, vertexOffset + 1 );
        interlockedStore( bMeshIndices, indexOffset + 5, vertexOffset + 2 );

		// Wireframe indices are generated as the following for each segment, the next segment will fill the gap
		// in between next and current vertices and we'll close it off with 2 more indices for the last segment
		// +-----+
		// |     |
		// |	 |
		interlockedStore( bMeshWireframeIndices, wireframeIndexOffset + 0, vertexOffset + 0 );
		interlockedStore( bMeshWireframeIndices, wireframeIndexOffset + 1, vertexOffset + 1 );
		interlockedStore( bMeshWireframeIndices, wireframeIndexOffset + 2, vertexOffset + 0 );
		interlockedStore( bMeshWireframeIndices, wireframeIndexOffset + 3, vertexOffset + 2 );
		interlockedStore( bMeshWireframeIndices, wireframeIndexOffset + 4, vertexOffset + 1 );
		interlockedStore( bMeshWireframeIndices, wireframeIndexOffset + 5, vertexOffset + 3 );

    	vertexOffset += 2;
    	indexOffset += 6;
    	wireframeIndexOffset += 6;
    }
	
	// Close off the last segment
	// +-----+
	interlockedStore( bMeshWireframeIndices, wireframeIndexOffset + 0,  vertexOffset + 0 );
	interlockedStore( bMeshWireframeIndices, wireframeIndexOffset + 1,  vertexOffset + 1 );
}
